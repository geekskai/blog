---
globs: *.ts,*.tsx
description: TypeScript coding standards and type safety guidelines for enterprise applications
---

# ğŸ“ TypeScript ç¼–ç æ ‡å‡† - TypeScript Coding Standards

## ğŸ—ï¸ ç±»å‹å®šä¹‰æ ‡å‡† (Type Definition Standards)

### ğŸ¯ æ¥å£è®¾è®¡åŸåˆ™

```typescript
// âœ… è‰¯å¥½çš„æ¥å£è®¾è®¡
interface WeatherData {
  readonly location: {
    readonly name: string
    readonly country: string
    readonly coordinates: {
      readonly lat: number
      readonly lon: number
    }
  }
  readonly current: CurrentWeather
  readonly snowDay: SnowDayPrediction
  readonly timestamp: string
}

interface CurrentWeather {
  readonly temperature: number
  readonly feelsLike: number
  readonly humidity: number
  readonly pressure: number
  readonly description: string
  readonly icon: string
  readonly windSpeed: number
  readonly windSpeedKmh: number
  readonly visibility: number
  readonly visibilityKm: number
  readonly snowfall: number
  readonly cloudCover: number
}

interface SnowDayPrediction {
  readonly probability: number
  readonly level: SnowDayLevel
  readonly color: string
  readonly recommendation: string
  readonly factors: SnowDayFactors
}

// ä½¿ç”¨å­—é¢é‡ç±»å‹ç¡®ä¿ç±»å‹å®‰å…¨
type SnowDayLevel = "Very Low" | "Low" | "Moderate" | "High" | "Very High"
type SearchType = "zip" | "city" | "coords"
type LoadingState = "idle" | "loading" | "success" | "error"
```

### ğŸ”§ æ³›å‹ä¸å®ç”¨ç±»å‹

```typescript
// é€šç”¨APIå“åº”ç±»å‹
interface ApiResponse<T> {
  readonly data: T
  readonly success: boolean
  readonly message?: string
  readonly timestamp: string
}

interface ApiError {
  readonly error: string
  readonly code?: number
  readonly details?: Record<string, unknown>
}

// æ¡ä»¶ç±»å‹ç”¨äºAPIçŠ¶æ€
type ApiResult<T> = ApiResponse<T> | ApiError

// å®ç”¨ç±»å‹ç»„åˆ
type PartialUpdate<T> = Partial<Pick<T, keyof T>>
type RequiredFields<T, K extends keyof T> = T & Required<Pick<T, K>>

// çŠ¶æ€ç®¡ç†ç±»å‹
interface AsyncState<T> {
  readonly data: T | null
  readonly loading: boolean
  readonly error: string | null
  readonly lastUpdated: Date | null
}

// Hookè¿”å›ç±»å‹
interface UseAsyncResult<T> extends AsyncState<T> {
  readonly execute: (params?: unknown) => Promise<void>
  readonly reset: () => void
}
```

### ğŸ¨ Reactç»„ä»¶ç±»å‹

```typescript
// ç»„ä»¶Propsç±»å‹å®šä¹‰
interface ButtonProps {
  readonly variant?: "primary" | "secondary" | "danger"
  readonly size?: "sm" | "md" | "lg"
  readonly loading?: boolean
  readonly disabled?: boolean
  readonly children: React.ReactNode
  readonly onClick?: (event: React.MouseEvent<HTMLButtonElement>) => void
  readonly className?: string
  readonly type?: "button" | "submit" | "reset"
}

// æ³›å‹ç»„ä»¶ç±»å‹
interface SelectOption<T = string> {
  readonly value: T
  readonly label: string
  readonly disabled?: boolean
}

interface SelectProps<T> {
  readonly options: SelectOption<T>[]
  readonly value: T | null
  readonly onChange: (value: T) => void
  readonly placeholder?: string
  readonly disabled?: boolean
  readonly multiple?: boolean
}

// è¡¨å•ç›¸å…³ç±»å‹
interface FormFieldProps<T> {
  readonly name: keyof T
  readonly value: T[keyof T]
  readonly onChange: (name: keyof T, value: T[keyof T]) => void
  readonly error?: string
  readonly required?: boolean
  readonly disabled?: boolean
}

// é«˜é˜¶ç»„ä»¶ç±»å‹
type WithLoadingProps<T> = T & {
  readonly isLoading: boolean
}

type HOC<TOriginalProps, TInjectedProps = {}> = (
  Component: React.ComponentType<TOriginalProps>
) => React.ComponentType<TOriginalProps & TInjectedProps>
```

## ğŸ¯ å‡½æ•°ä¸Hookç±»å‹å®‰å…¨

### ğŸª è‡ªå®šä¹‰Hookç±»å‹

```typescript
// å¼‚æ­¥æ•°æ®è·å–Hook
function useAsyncData<T>(
  fetcher: () => Promise<T>,
  dependencies: React.DependencyList = []
): UseAsyncResult<T> {
  const [state, setState] = useState<AsyncState<T>>({
    data: null,
    loading: false,
    error: null,
    lastUpdated: null,
  })

  const execute = useCallback(async () => {
    setState((prev) => ({ ...prev, loading: true, error: null }))

    try {
      const data = await fetcher()
      setState({
        data,
        loading: false,
        error: null,
        lastUpdated: new Date(),
      })
    } catch (error) {
      setState((prev) => ({
        ...prev,
        loading: false,
        error: error instanceof Error ? error.message : "Unknown error",
      }))
    }
  }, dependencies)

  const reset = useCallback(() => {
    setState({
      data: null,
      loading: false,
      error: null,
      lastUpdated: null,
    })
  }, [])

  useEffect(() => {
    execute()
  }, [execute])

  return { ...state, execute, reset }
}

// æœ¬åœ°å­˜å‚¨Hook
function useLocalStorage<T>(
  key: string,
  initialValue: T
): [T, (value: T | ((prev: T) => T)) => void] {
  const [storedValue, setStoredValue] = useState<T>(() => {
    if (typeof window === "undefined") return initialValue

    try {
      const item = window.localStorage.getItem(key)
      return item ? JSON.parse(item) : initialValue
    } catch (error) {
      console.warn(`Error reading localStorage key "${key}":`, error)
      return initialValue
    }
  })

  const setValue = useCallback(
    (value: T | ((prev: T) => T)) => {
      try {
        const valueToStore = value instanceof Function ? value(storedValue) : value
        setStoredValue(valueToStore)

        if (typeof window !== "undefined") {
          window.localStorage.setItem(key, JSON.stringify(valueToStore))
        }
      } catch (error) {
        console.warn(`Error setting localStorage key "${key}":`, error)
      }
    },
    [key, storedValue]
  )

  return [storedValue, setValue]
}
```

### ğŸ”„ äº‹ä»¶å¤„ç†ç±»å‹

```typescript
// è¡¨å•äº‹ä»¶å¤„ç†
type FormSubmitHandler<T = HTMLFormElement> = (event: React.FormEvent<T>) => void | Promise<void>

type InputChangeHandler<T = HTMLInputElement> = (event: React.ChangeEvent<T>) => void

type ButtonClickHandler<T = HTMLButtonElement> = (
  event: React.MouseEvent<T>
) => void | Promise<void>

// æœç´¢ç›¸å…³äº‹ä»¶
interface SearchEvents {
  readonly onSubmit: FormSubmitHandler
  readonly onInputChange: InputChangeHandler
  readonly onTypeChange: (type: SearchType) => void
  readonly onLocationSelect: (location: string) => void
  readonly onGeoLocation: ButtonClickHandler
}

// é”®ç›˜äº‹ä»¶å¤„ç†
type KeyboardEventHandler<T = HTMLElement> = (event: React.KeyboardEvent<T>) => void

const handleKeyDown: KeyboardEventHandler = (event) => {
  if (event.key === "Enter" && !event.shiftKey) {
    event.preventDefault()
    // å¤„ç†å›è½¦é”®
  }
}
```

## ğŸ›¡ï¸ ç±»å‹å®ˆå«ä¸éªŒè¯

### âœ… ç±»å‹å®ˆå«å‡½æ•°

```typescript
// åŸºç¡€ç±»å‹å®ˆå«
function isString(value: unknown): value is string {
  return typeof value === "string"
}

function isNumber(value: unknown): value is number {
  return typeof value === "number" && !isNaN(value)
}

function isArray<T>(value: unknown): value is T[] {
  return Array.isArray(value)
}

// å¯¹è±¡ç±»å‹å®ˆå«
function isWeatherData(value: unknown): value is WeatherData {
  return (
    typeof value === "object" &&
    value !== null &&
    "location" in value &&
    "current" in value &&
    "snowDay" in value &&
    "timestamp" in value
  )
}

function hasProperty<T extends PropertyKey>(obj: object, prop: T): obj is Record<T, unknown> {
  return prop in obj
}

// APIå“åº”éªŒè¯
function isApiResponse<T>(
  value: unknown,
  dataValidator: (data: unknown) => data is T
): value is ApiResponse<T> {
  return (
    typeof value === "object" &&
    value !== null &&
    hasProperty(value, "data") &&
    hasProperty(value, "success") &&
    typeof value.success === "boolean" &&
    dataValidator(value.data)
  )
}

// ä½¿ç”¨ç¤ºä¾‹
async function fetchWeatherData(location: string): Promise<WeatherData> {
  const response = await fetch(`/api/weather?q=${encodeURIComponent(location)}`)
  const data = await response.json()

  if (!isWeatherData(data)) {
    throw new Error("Invalid weather data received")
  }

  return data
}
```

### ğŸ” è¿è¡Œæ—¶éªŒè¯

```typescript
// Zod schemaéªŒè¯
import { z } from "zod"

const WeatherRequestSchema = z
  .object({
    type: z.enum(["city", "coords", "zip"]),
    q: z.string().optional(),
    lat: z
      .string()
      .regex(/^-?\d+\.?\d*$/)
      .optional(),
    lon: z
      .string()
      .regex(/^-?\d+\.?\d*$/)
      .optional(),
    zip: z.string().min(3).max(10).optional(),
  })
  .refine(
    (data) => {
      if (data.type === "city") return data.q
      if (data.type === "coords") return data.lat && data.lon
      if (data.type === "zip") return data.zip
      return false
    },
    {
      message: "Missing required fields for search type",
    }
  )

type WeatherRequest = z.infer<typeof WeatherRequestSchema>

// è¡¨å•éªŒè¯Schema
const SearchFormSchema = z.object({
  searchType: z.enum(["zip", "city", "coords"]),
  location: z.string().min(1, "Location is required"),
  useGeolocation: z.boolean().optional(),
})

type SearchFormData = z.infer<typeof SearchFormSchema>
```

## ğŸ¯ é”™è¯¯å¤„ç†ç±»å‹

### ğŸš¨ é”™è¯¯ç±»å‹å®šä¹‰

```typescript
// è‡ªå®šä¹‰é”™è¯¯ç±»
class WeatherApiError extends Error {
  constructor(
    message: string,
    public readonly code?: number,
    public readonly details?: Record<string, unknown>
  ) {
    super(message)
    this.name = "WeatherApiError"
  }
}

class ValidationError extends Error {
  constructor(
    message: string,
    public readonly field: string,
    public readonly value: unknown
  ) {
    super(message)
    this.name = "ValidationError"
  }
}

// é”™è¯¯è”åˆç±»å‹
type AppError = WeatherApiError | ValidationError | Error

// Resultç±»å‹æ¨¡å¼
type Result<T, E = Error> = { success: true; data: T } | { success: false; error: E }

// å®‰å…¨çš„å¼‚æ­¥å‡½æ•°åŒ…è£…
async function safeAsync<T>(fn: () => Promise<T>): Promise<Result<T, AppError>> {
  try {
    const data = await fn()
    return { success: true, data }
  } catch (error) {
    return {
      success: false,
      error: error instanceof Error ? error : new Error(String(error)),
    }
  }
}

// ä½¿ç”¨ç¤ºä¾‹
async function handleSearch(location: string): Promise<Result<WeatherData, AppError>> {
  return safeAsync(async () => {
    const validation = SearchFormSchema.safeParse({ location, searchType: "city" })

    if (!validation.success) {
      throw new ValidationError("Invalid input", "location", location)
    }

    const response = await fetch(`/api/weather?q=${encodeURIComponent(location)}`)

    if (!response.ok) {
      throw new WeatherApiError(`HTTP ${response.status}`, response.status)
    }

    const data = await response.json()

    if (!isWeatherData(data)) {
      throw new WeatherApiError("Invalid response format")
    }

    return data
  })
}
```

## ğŸ”§ å®ç”¨å·¥å…·ç±»å‹

### ğŸ› ï¸ é€šç”¨å·¥å…·ç±»å‹

```typescript
// æ·±åº¦åªè¯»
type DeepReadonly<T> = {
  readonly [P in keyof T]: T[P] extends object ? DeepReadonly<T[P]> : T[P]
}

// æ·±åº¦å¯é€‰
type DeepPartial<T> = {
  [P in keyof T]?: T[P] extends object ? DeepPartial<T[P]> : T[P]
}

// æå–å‡½æ•°å‚æ•°ç±»å‹
type ExtractParams<T> = T extends (...args: infer P) => unknown ? P : never

// æå–Promiseç±»å‹
type Awaited<T> = T extends Promise<infer U> ? U : T

// æ¡ä»¶ç±»å‹å·¥å…·
type NonNullable<T> = T extends null | undefined ? never : T
type Optional<T, K extends keyof T> = Omit<T, K> & Partial<Pick<T, K>>
type Required<T, K extends keyof T> = T & Required<Pick<T, K>>

// å­—ç¬¦ä¸²æ“ä½œç±»å‹
type Capitalize<S extends string> = S extends `${infer T}${infer U}` ? `${Uppercase<T>}${U}` : S

type CamelCase<S extends string> = S extends `${infer P1}_${infer P2}${infer P3}`
  ? `${P1}${Uppercase<P2>}${CamelCase<P3>}`
  : S

// å¯¹è±¡è·¯å¾„ç±»å‹
type Path<T> = T extends object
  ? {
      [K in keyof T]: K extends string
        ? T[K] extends object
          ? `${K}` | `${K}.${Path<T[K]>}`
          : `${K}`
        : never
    }[keyof T]
  : never

type PathValue<T, P extends Path<T>> = P extends `${infer K}.${infer Rest}`
  ? K extends keyof T
    ? Rest extends Path<T[K]>
      ? PathValue<T[K], Rest>
      : never
    : never
  : P extends keyof T
    ? T[P]
    : never
```

### ğŸ¨ ç»„ä»¶å·¥å…·ç±»å‹

```typescript
// å¤šæ€ç»„ä»¶ç±»å‹
type PolymorphicRef<C extends React.ElementType> =
  React.ComponentPropsWithRef<C>['ref']

type AsProp<C extends React.ElementType> = {
  as?: C
}

type PropsToOmit<C extends React.ElementType, P> =
  keyof (AsProp<C> & P)

type PolymorphicComponentProp<
  C extends React.ElementType,
  Props = {}
> = React.PropsWithChildren<Props & AsProp<C>> &
  Omit<React.ComponentPropsWithoutRef<C>, PropsToOmit<C, Props>>

type PolymorphicComponentPropWithRef<
  C extends React.ElementType,
  Props = {}
> = PolymorphicComponentProp<C, Props> & { ref?: PolymorphicRef<C> }

// ä½¿ç”¨ç¤ºä¾‹
interface BoxOwnProps {
  color?: string
  size?: number
}

type BoxProps<C extends React.ElementType> =
  PolymorphicComponentPropWithRef<C, BoxOwnProps>

const Box = <C extends React.ElementType = 'div'>({
  as,
  color,
  size,
  children,
  ...rest
}: BoxProps<C>) => {
  const Component = as || 'div'
  return (
    <Component
      style={{ color, fontSize: size }}
      {...rest}
    >
      {children}
    </Component>
  )
}

// ç±»å‹å®‰å…¨çš„ä½¿ç”¨
<Box as="button" onClick={() => {}}>Button</Box>
<Box as="a" href="/">Link</Box>
```

è¿™å¥—TypeScriptæ ‡å‡†ç¡®ä¿ä»£ç å…·å¤‡å¼ºç±»å‹å®‰å…¨æ€§ã€è‰¯å¥½çš„å¼€å‘ä½“éªŒå’Œè¿è¡Œæ—¶ç¨³å®šæ€§ã€‚
